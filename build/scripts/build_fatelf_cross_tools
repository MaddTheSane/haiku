#!/bin/sh

CWD=`pwd`

# Print an info-level message
info() {
	echo "$1"
}

fprintf() {
	local fd="$1"
	local msg="$2"
	echo "${msg}" 1>&${fd}
}

# Print an error-level message to stderr
error() {
	fprintf 2 "ERROR: $1"
}

# Print a fatal message to stderr and exit
fatal() {
	error "$1"
	exit 1
}

# Check for a non-zero error code
# If non-zero, print the fatal error message
check_error() {
	if [ $? != 0 ]; then
		fatal "$1"
	fi
}

# Resolve a relative path
abspath() {
	local path="$1"
	local var="$2"
	case "${path}" in
		/*)
			# Nothing to do, absolute path
			;;
		*)
			eval "${var}=\"${CWD}/${path}\""
			;;
	esac
}

find_tool() {
	local varname="$1"
	shift
	local names="$*"

	while [ ! -z "${1}" ]; do
		local path=`which "${1}"`
		if [ ! -z "${path}" ]; then
			eval "${varname}=\"${path}\""
			return
		fi
		shift
	done

	fatal "Could not find required tool: ${names}"
}

safe_mkdir() {
	local dir="$1"
	mkdir -p "${dir}"
	check_error "Failed to create directory: ${dir}"
}

safe_cp() {
	local src="$1"
	local dest="$2"
	cp "${src}" "${dest}"
	check_error "Failed to copy file"
}

# Push a new working directory and verify success
safe_push_cwd() {
	local dir="$1"
	pushd "${dir}" >/dev/null
	check_error "Failed to change to directory: ${dir}"
}

# Pop a working directory pushed via safe_push_cwd
safe_pop_cwd() {
	popd >/dev/null
	check_error "Failed to change cwd"
}

# Create a hard link from arg2 (dest) to arg1 (source)
safe_ln() {
	local src="$1"
	local dest="$2"

	ln -f "${src}" "${dest}"
	check_error "ln $1 $2 failed"
}

# Append a value to a list and echo the result to stdout.
list_append() {
	local list="$1"
	local value="$2"

	# Use xargs to strip excess whitespace
	echo "${list}" "${2}" | xargs
}

# Perform an autotools build
run_autoconf() {
	local tool="$1"
	local objdir="$2"
	local prefix="$3"

	# Move the configure args to pos $1
	shift;
	shift;
	shift;

	local srcdir="${BUILDTOOLS}/$tool"
	local builddir="${OBJROOT}/$objdir"

	safe_mkdir "${builddir}"
	safe_push_cwd "${builddir}"

	"${srcdir}/configure" -C --prefix="${prefix}" $@ >> "${LOGFILE}" 2>&1
	check_error "Configure failed"
}

# Perform a cmake build
run_cmake() {
	local tool="$1"
	local objdir="$2"
	local prefix="$3"
	local srcdir="${BUILDTOOLS}/$tool"
	local builddir="${OBJROOT}/$objdir"

	safe_mkdir "${builddir}"
	safe_push_cwd "${builddir}"

	"${CMAKE}" "-DCMAKE_INSTALL_PREFIX:PATH=${prefix}" "${srcdir}" >> "${LOGFILE}" 2>&1
	check_error "${CMAKE} failed"
}

# Install using gmake. Assumes that the Makefile supports DESTDIR, which should
# be the case when using either autoconf or cmake
run_gmake() {
	local objdir="$1"

	# Move the make args to pos $1
	shift;

	local builddir="${OBJROOT}/$objdir"
	safe_push_cwd "${builddir}"

	if [ -z "${DESTROOT}" ]; then
		"${GMAKE}" ${JOBS} $@ >> "${LOGFILE}" 2>&1
	else
		# Ensure that our caller can override DESTDIR by placing the caller's
		# arguments after our own.
		"${GMAKE}" ${JOBS} "DESTDIR=${DESTROOT}" $@ >> "${LOGFILE}" 2>&1
	fi

	check_error "${GMAKE} failed"
}

# touch all info files in order to avoid the dependency on makeinfo
# (which apparently doesn't work reliably on all the different host 
# configurations and changes files which in turn appear as local changes
# to the VCS).
touch_mkinfo() {
	local tool="$1"
	local srcdir="${BUILDTOOLS}/$tool"

	find "${srcdir}" -name \*.info -exec touch \{\} \;
	check_error "touch_mkinfo() failed"
}

# copy headers used for the build
copy_headers() {
	local src=$1
	local target=$2

	headers="$(find "$src" -name \*\.h)"
	check_error "searching for headers failed"

	headers="$(echo $headers | sed -e "s@$src/@@g")"
	check_error "sed failed"

	for f in $headers; do
		local header_dir="$target/$(dirname $f)"
		safe_mkdir "$header_dir"
		safe_cp "$src/$f" "$header_dir"
	done
}

# Build all tools
cmd_build() {
	local binpath="${DESTROOT}/${PREFIX}/bin"
	safe_mkdir "${binpath}"

	# Native FatELF tools are required for all additional builds
	info "Building FatELF tools"
	run_cmake "fatelf" "fatelf-objs" "${PREFIX}"

	info "Installing FatELF tools"
	run_gmake "fatelf-objs" install

	# Create compatibility links for front-end compiler/assembler drivers
	safe_ln "${binpath}/fatelf-gcc" "${binpath}/gcc"
	safe_ln "${binpath}/fatelf-gcc" "${binpath}/g++"
	safe_ln "${binpath}/fatelf-as" "${binpath}/as"


	# Generate portable binutils for all targets. We'll have to build as(1)
	# seperately.
	eval set -- "${TARGET_TRIPLES}"
	local binutils_target="$1"
	local binutils_targets=`echo "${TARGET_TRIPLES}" | sed 's/ /,/g'`

	info "Building binutils"
	touch_mkinfo "binutils"
	run_autoconf "binutils" "binutils-objs" "${PREFIX}" \
		--program-prefix="" \
		--without-gnu-as \
		"--target=${binutils_target}" \
		"--enable-targets=${binutils_targets}"
	run_gmake "binutils-objs" tooldir="${PREFIX}"

	info "Installing binutils"
	run_gmake "binutils-objs" tooldir="${PREFIX}" install

	# Build (just) the assembler for all supported targets
	for arch in ${TARGETS}; do
		info "Building assembler for ${arch}"

		local arch_prefix="${PREFIX}/$(arch_triple ${arch})"
		run_autoconf "binutils" "binutils-${arch}-objs" "${arch_prefix}" \
			--program-prefix="" \
			"--target=$(arch_triple ${arch})"

		run_gmake "binutils-${arch}-objs" tooldir="${arch_prefix}" all

		info "Installing assembler for ${arch}"
		run_gmake "binutils-${arch}-objs" tooldir="${arch_prefix}" install-gas
	done

	# The GCC build process expects to find toolchain commands under names
	# like '<triplet>-<cmd>'. Some commands (ie, ranlib) change their behavior
	# depending on the name under which they're called, so we have to use
	# a shell script for indirection.
	local gcc_toolpath="${OBJROOT}/gcc-bin"
	safe_mkdir "${gcc_toolpath}"

	for arch in ${TARGETS}; do
		for prog in ar nm ranlib strip ld as; do
			local cmdname="$(arch_triple ${arch})-${prog}"
			local cmdpath="${gcc_toolpath}/${cmdname}"

			echo '#!/bin/sh' > "${cmdpath}" || exit 1

			if [ "${prog}" = "as" ]; then
				echo "exec \"${binpath}/${prog}\" -arch \"${arch}\" \$*" >> "${cmdpath}" || exit 1
			else
				echo "exec \"${binpath}/${prog}\" \$*" >> "${cmdpath}" || exit 1
			fi
			chmod a+x "${cmdpath}" || exit 1
		done
	done

	# Build the compiler for M:N hosts:targets
	# Populate the object root
	local sysinc="${OBJROOT}/sysincludes"
	local syslib="${OBJROOT}/syslib"

	safe_mkdir "${syslib}"
	safe_mkdir "${sysinc}"

	copy_headers "${HAIKU_SRC}/headers/config" "$sysinc/config"
	copy_headers "${HAIKU_SRC}/headers/os" "$sysinc/os"
	copy_headers "${HAIKU_SRC}/headers/posix" "$sysinc/posix"

	local orig_PATH="${PATH}"
	export PATH="${gcc_toolpath}:${PATH}"

	touch_mkinfo "gcc"
	for arch in ${TARGETS}; do
		info "Building compiler for ${arch}"

		run_autoconf "gcc" "gcc-${arch}-objs" "${PREFIX}" \
				--program-prefix="$(arch_triple ${arch})-" \
				--target="$(arch_triple ${arch})" \
				--with-headers="$sysinc" \
				--with-libs="$syslib" \
				--disable-nls \
				--disable-shared \
				--without-libiconv-prefix \
				--disable-libstdcxx-pch \
				--with-htmldir=html-docs --enable-lto \
				--enable-frame-pointer
		run_gmake "gcc-${arch}-objs"

		info "Installing compiler for ${arch}"
		run_gmake "gcc-${arch}-objs" \
			DESTDIR="${OBJROOT}/gcc-${arch}-root" \
			install-gcc
			# FATELF_TODO -- should only be enabled when host=target
			# This will have to wait until we have a self-hosting toolchain
			#install-target
	done
	export PATH="${orig_PATH}"

	# TODO - Install+merge compiler results
}

# Clean the build output
cmd_clean() {
	info "Cleaning ${OBJROOT} ..."
	rm -rf "${OBJROOT}"
}

# Clean the build output and destroot
cmd_distclean() {
	cmd_clean
	if [ ! -z "${DESTROOT}" ]; then
		info "Cleaning ${DESTROOT} ..."
		# TODO - verify
		echo rm -rf "${DESTROOT}"
	fi
}

# Compute the triple for the given arch, and echo
# it to stdout
arch_triple() {
	local arch="$1"

	case "$arch" in
		x86)
			local triple=i586-pc-haiku
			;;
		x86_64)
			local triple=x86_64-unknown-haiku
			;;
		ppc)
			local triple=powerpc-apple-haiku
			;;
		m68k)
			local triple=m68k-unknown-haiku
			;;
		arm)
			local triple=arm-unknown-haiku
			;;
		mipsel)
			local triple=mipsel-unknown-haiku
			;;
		*)
			fatal "Unsupported architecture: $2"
			;;
	esac

	echo "${triple}"
}

# Map arch types to their triple, and generate a ${prefix}_TRIPLES variable
# containing the space-seperated triples.
compute_triples() {
	local varprefix="$1"
	local archs="$2"


	for arch in ${TARGETS}; do
		local triple=$(arch_triple "${arch}")
		local triples=$(list_append "${triples}" "${triple}")
		local arch_flags=$(list_append "${arch_flags}" "-arch ${arch}")
	done

	eval "${varprefix}_ARCH_FLAGS=\"${arch_flags}\""
	eval "${varprefix}_TRIPLES=\"${triples}\""
}

main() {
	# Find required tools
	find_tool GMAKE gmake make
	find_tool CMAKE	cmake

	# Parse architectures and compute the appropriate triples
	compute_triples "TARGET" "${TARGETS}"
	compute_triples "HOST" "${HOSTS}"

	info "Configured for targets: ${TARGETS}"
	if [ ! -z "${HOSTS}" ]; then
		info "Configured for hosts: ${HOSTS}"

		# TODO: We can't actually support/test this until the fat
		# toolchains are self hosting
		fatal "TODO: Fat host builds are not currently supported"
	fi

	info "Logging to ${LOGFILE}"
	safe_mkdir `dirname "${LOGFILE}"`
	echo -n '' >"${LOGFILE}"

	case "${COMMAND}" in
		build)
			cmd_build
			;;
		clean)
			cmd_clean
			;;
		distclean)
			cmd_distclean
			;;
		*)
			fatal_usage "Unknown command: ${cmd}"
			;;
	esac
}

# Print usage
usage() {
	# Output to stderr if this occured due to an error, otherwise, stdout
	# This allows users to page the output of --help, in which case there
	# isn't an error, and usage is the expected output
	local err="$1"
	if [ -z "${err}" ]; then
		local fd="1"
	else
		local fd="2"
	fi

	fprintf $fd "Usage: $0 <options> <command>"
	fprintf $fd "Required Options: "
	fprintf $fd "  --targets    The target architectures for which cross tools will be built"
	fprintf $fd "               (x86, x86_64, arm, ppc, m68k, mipsel)"
	fprintf $fd "  --prefix     The binary installation prefix (eg, /usr/local)."
	fprintf $fd "  --objroot    The directory in which the tool builds will be performed"
	fprintf $fd "  --buildtools The path to the Haiku buildtools checkout."
	fprintf $fd "  --haiku      The path to the Haiku sources."

	fprintf $fd ""
	fprintf $fd "Options:"
	fprintf $fd "  -jN          The number of concurrent build jobs. Passed to make."
	fprintf $fd "  --destroot   The installation destroot. This is where the files will"
	fprintf $fd "               actually be installed."
	fprintf $fd "  --hosts      The host architectures for which the cross tools will be built."
	fprintf $fd "               Accepts the same architecture values as --targets."
	fprintf $fd "               This value is not supported when building a cross-compiler on a"
	fprintf $fd "               non-FatELF host."

	fprintf $fd ""
	fprintf $fd "Commands: "
	fprintf $fd "  clean		Clean any intermediate build output."
	fprintf $fd "  distclean	Clean any intermediate build output, as well as the target"
	fprintf $fd "               destroot (Caution!)."
	fprintf $fd "  build		Build and install the cross tools (in the destroot, if"
	fprintf $fd "               specified)."
}

# Print the provided message, usage, and then exit with an error
fatal_usage() {
	local msg="$1"
	error "${msg}\n"
	usage 1
	exit 1
}

# Verify that a required option was supplied
require_opt() {
	local optname="$1"
	local var="$2"
	if [ -z "${var}" ]; then
		fatal_usage "Missing required flag ${optname}"
	fi
}

# Verify that a required option was supplied and points
# to an existing directory.
require_dir_opt() {
	local optname="$1"
	local dir="$2"

	require_opt "${optname}" "${dir}"
	if [ -f "${dir}" ]; then
		fatal "Not a directory: ${dir}"
	fi

	if [ ! -d "${dir}" ]; then
		fatal "No such directory: ${dir}"
	fi
}


# Parse command line arguments
while [ $# -gt 0 ]; do
	case $1 in
		--targets)
			shift
			TARGETS="$1"
			shift
			;;
		--hosts)
			shift
			HOSTS="$1"
			shift
			;;
		--prefix)
			shift
			abspath "$1" PREFIX
			shift
			;;
		--objroot)
			shift
			abspath "$1" OBJROOT
			shift
			;;
		--destroot)
			shift
			abspath "$1" DESTROOT
			shift
			;;
		--buildtools)
			shift
			abspath "$1" BUILDTOOLS
			shift
			;;
		--haiku)
			shift
			abspath "$1" HAIKU_SRC
			shift
			;;
		-j)
			shift
			JOBS="-j$1"
			shift
			;;
		-j*)
			JOBS="$1"
			shift
			;;
		-h|--help)
			usage
			exit 0
			;;
		-*)
			fatal_usage "Unknown option $1"
			;;
		*)
			# Check if command has already been specified
			if [ ! -z "${COMMAND}" ]; then
				fatal_usage "Unexpected command $1. Multiple commands were specified"
			fi
			COMMAND="${1}"
			shift
			;;
	esac
done

if [ "${COMMAND}" != "clean" ] && [ "${COMMAND}"  != "distclean" ]; then
	require_opt "--prefix" "${PREFIX}"
	require_opt "--targets" "${TARGETS}"
	require_dir_opt "--buildtools" "${BUILDTOOLS}"
	require_dir_opt "--haiku" "${HAIKU_SRC}"
fi

require_opt "--objroot" "${OBJROOT}"

if [ -z "${COMMAND}" ]; then
	fatal_usage "Missing required command"
	exit 1
fi

LOGFILE="${OBJROOT}/build.log"

# Run the main routine
main