#!/bin/sh

CWD=`pwd`

# Print an info-level message
info() {
	echo "$1"
}

fprintf() {
	local fd="$1"
	local msg="$2"
	echo "${msg}" 1>&${fd}
}

# Print an error-level message to stderr
error() {
	fprintf 2 "ERROR: $1"
}

# Print a fatal message to stderr and exit
fatal() {
	error "$1"
	exit 1
}

# Check for a non-zero error code
# If non-zero, print the fatal error message
check_error() {
	if [ $? != 0 ]; then
		fatal "$1"
	fi
}

# "Return" a value in global $retval
retval() {
	retval="$1"
}

# Resolve a relative path
abspath() {
	local path="$1"
	local var="$2"
	case "${path}" in
		/*)
			# Nothing to do, absolute path
			;;
		*)
			eval "${var}=\"${CWD}/${path}\""
			;;
	esac
}

find_tool() {
	local varname="$1"
	shift
	local names="$*"

	while [ ! -z "${1}" ]; do
		local path=`which "${1}"`
		if [ ! -z "${path}" ]; then
			eval "${varname}=\"${path}\""
			return
		fi
		shift
	done

	fatal "Could not find required tool: ${names}"
}

safe_mkdir() {
	local dir="$1"
	mkdir -p "${dir}"
	check_error "Failed to create directory: ${dir}"
}

# Push a new working directory and verify success
safe_push_cwd() {
	local dir="$1"
	pushd "${dir}" >/dev/null
	check_error "Failed to change to directory: ${dir}"
}

# Pop a working directory pushed via safe_push_cwd
safe_pop_cwd() {
	popd >/dev/null
	check_error "Failed to change cwd"
}

# Append a value to a list and echo the result to stdout.
list_append() {
	local list="$1"
	local value="$2"

	# Use xargs to strip excess whitespace
	echo "${list}" "${2}" | xargs
}

# Perform an autotools build
run_autoconf() {
	local tool="$1"
	local objdir="$2"
	local prefix="$3"

	# Move the configure args to pos $1
	shift;
	shift;
	shift;

	local srcdir="${BUILDTOOLS}/$tool"
	local builddir="${OBJROOT}/$objdir"

	safe_mkdir "${builddir}"
	safe_push_cwd "${builddir}"

	"${srcdir}/configure" -C --prefix="${prefix}" $@ >> "${LOGFILE}" 2>&1
	check_error "Configure failed"
}

# Perform a cmake build
run_cmake() {
	local tool="$1"
	local objdir="$2"
	local prefix="$3"
	local srcdir="${BUILDTOOLS}/$tool"
	local builddir="${OBJROOT}/$objdir"

	safe_mkdir "${builddir}"
	safe_push_cwd "${builddir}"

	"${CMAKE}" "-DCMAKE_INSTALL_PREFIX:PATH=${prefix}" "${srcdir}" >> "${LOGFILE}" 2>&1
	check_error "${CMAKE} failed"
}

# Install using gmake. Assumes that the Makefile supports DESTDIR, which should
# be the case when using either autoconf or cmake
run_gmake() {
	local objdir="$1"

	# Move the make args to pos $1
	shift;

	local builddir="${OBJROOT}/$objdir"
	safe_push_cwd "${builddir}"

	if [ -z "${DESTROOT}" ]; then
		"${GMAKE}" ${JOBS} $@ >> "${LOGFILE}" 2>&1
	else
		"${GMAKE}" ${JOBS} "DESTDIR=${DESTROOT}" $@ >> "${LOGFILE}" 2>&1
	fi

	check_error "${GMAKE} failed"
}

# Build all tools
cmd_build() {
	# Native FatELF tools are required for all additional builds
	info "Building FatELF tools"
	run_cmake "fatelf" "fatelf-objs" "${PREFIX}"
	run_gmake "fatelf-objs" install

	# Generate portable binutils for all targets. We'll have to build as(1)
	# seperately.
	eval set -- "${TARGET_TRIPLES}"
	local binutils_target="$1"
	local binutils_targets=`echo "${TARGET_TRIPLES}" | sed 's/ /,/g'`

	info "Building binutils for all targets"
	run_autoconf "binutils" "binutils-objs" "${PREFIX}" \
		--program-prefix="" \
		--without-gnu-as \
		"--target=${binutils_target}" \
		"--enable-targets=${binutils_targets}"
	run_gmake "binutils-objs" tooldir="${PREFIX}"
	run_gmake "binutils-objs" tooldir="${PREFIX}" install

	# Build (just) the assembler for all supported targets
	for arch in ${TARGETS}; do
		info "Building assembler for ${arch}"

		local arch_prefix="${PREFIX}/libexec/as/${arch}"
		run_autoconf "binutils" "binutils-${arch}-objs" "${arch_prefix}" \
			--program-prefix="" \
			"--target=$(arch_triple ${arch})"

		run_gmake "binutils-${arch}-objs" tooldir="${arch_prefix}" configure-gas
		run_gmake "binutils-${arch}-objs" tooldir="${arch_prefix}" gas
		run_gmake "binutils-${arch}-objs" tooldir="${arch_prefix}" install-gas
	done

	# Build the compiler for M:N hosts:targets
	# TODO
}

# Clean the build output
cmd_clean() {
	info "Cleaning ${OBJROOT} ..."
	rm -rf "${OBJROOT}"
}

# Clean the build output and destroot
cmd_distclean() {
	cmd_clean
	if [ ! -z "${DESTROOT}" ]; then
		info "Cleaning ${DESTROOT} ..."
		# TODO - verify
		echo rm -rf "${DESTROOT}"
	fi
}

# Compute the triple for the given arch, and echo
# it to stdout
arch_triple() {
	local arch="$1"

	case "$arch" in
		x86)
			local triple=i586-pc-haiku
			;;
		x86_64)
			local triple=x86_64-unknown-haiku
			;;
		ppc)
			local triple=powerpc-apple-haiku
			;;
		m68k)
			local triple=m68k-unknown-haiku
			;;
		arm)
			local triple=arm-unknown-haiku
			;;
		mipsel)
			local triple=mipsel-unknown-haiku
			;;
		*)
			fatal "Unsupported architecture: $2"
			;;
	esac

	echo "${triple}"
}

# Map arch types to their triple, and generate a ${prefix}_TRIPLES variable
# containing the space-seperated triples.
compute_triples() {
	local varprefix="$1"
	local archs="$2"


	for arch in ${TARGETS}; do
		local triple=$(arch_triple "${arch}")
		local triples=$(list_append "${triples}" "${triple}")
		local arch_flags=$(list_append "${arch_flags}" "-arch ${arch}")
	done

	eval "${varprefix}_ARCH_FLAGS=\"${arch_flags}\""
	eval "${varprefix}_TRIPLES=\"${triples}\""
}

main() {
	# Find required tools
	find_tool GMAKE gmake make
	find_tool CMAKE	cmake

	# Parse architectures and compute the appropriate triples
	compute_triples "TARGET" "${TARGETS}"
	compute_triples "HOST" "${HOSTS}"

	info "Configured for targets: ${TARGETS}"
	if [ ! -z "${HOSTS}" ]; then
		info "Configured for hosts: ${HOSTS}"

		# TODO: We can't actually support/test this until the fat
		# toolchains are self hosting
		fatal "TODO: Fat host builds are not currently supported"
	fi

	info "Logging to ${LOGFILE}"
	safe_mkdir `dirname "${LOGFILE}"`
	echo -n '' >"${LOGFILE}"

	case "${COMMAND}" in
		build)
			cmd_build
			;;
		clean)
			cmd_clean
			;;
		distclean)
			cmd_distclean
			;;
		*)
			fatal_usage "Unknown command: ${cmd}"
			;;
	esac
}

# Print usage
usage() {
	# Output to stderr if this occured due to an error, otherwise, stdout
	# This allows users to page the output of --help, in which case there
	# isn't an error, and usage is the expected output
	local err="$1"
	if [ -z "${err}" ]; then
		local fd="1"
	else
		local fd="2"
	fi

	fprintf $fd "Usage: $0 <options> <command>"
	fprintf $fd "Required Options: "
	fprintf $fd "  --targets	The target architectures for which cross tools will be built (x86, x86_64, arm, ppc, m68k, mipsel)"
	fprintf $fd "  --prefix		The binary installation prefix (eg, /usr/local)."
	fprintf $fd "  --objroot	The directory in which the tool builds will be performed"
	fprintf $fd "  --buildtools	The path to the Haiku buildtools checkout."

	fprintf $fd ""
	fprintf $fd "Options:"
	fprintf $fd "  -jN			The number of concurrent build jobs. Passed to make."
	fprintf $fd "  --destroot	The installation destroot. This is where the files will actually be installed."
	fprintf $fd "  --hosts		The host architectures for which the cross tools will be built."
	fprintf $fd "  				Accepts the same architecture values as --targets."
	fprintf $fd "  				This value is not supported when building a cross-compiler on a non-FatELF host."

	fprintf $fd ""
	fprintf $fd "Commands: "
	fprintf $fd "  clean		Clean any intermediate build output."
	fprintf $fd "  distclean	Clean any intermediate build output, as well as the target destroot (Caution!)."
	fprintf $fd "  build		Build and install the cross tools (in the destroot, if specified)."
}

# Print the provided message, usage, and then exit with an error
fatal_usage() {
	local msg="$1"
	error "${msg}\n"
	usage 1
	exit 1
}

# Verify that a required option was supplied
require_opt() {
	local optname="$1"
	local var="$2"
	if [ -z "${var}" ]; then
		fatal_usage "Missing required flag ${optname}"
	fi
}

# Verify that a required option was supplied and points
# to an existing directory.
require_dir_opt() {
	local optname="$1"
	local dir="$2"

	require_opt "${optname}" "${dir}"
	if [ -f "${dir}" ]; then
		fatal "Not a directory: ${dir}"
	fi

	if [ ! -d "${dir}" ]; then
		fatal "No such directory: ${dir}"
	fi
}


# Parse command line arguments
while [ $# -gt 0 ]; do
	case $1 in
		--targets)
			shift
			TARGETS="$1"
			shift
			;;
		--hosts)
			shift
			HOSTS="$1"
			shift
			;;
		--prefix)
			shift
			abspath "$1" PREFIX
			shift
			;;
		--objroot)
			shift
			abspath "$1" OBJROOT
			shift
			;;
		--destroot)
			shift
			abspath "$1" DESTROOT
			shift
			;;
		--buildtools)
			shift
			abspath "$1" BUILDTOOLS
			shift
			;;
		-j)
			shift
			JOBS="-j$1"
			shift
			;;
		-j*)
			JOBS="$1"
			shift
			;;
		-h|--help)
			usage
			exit 0
			;;
		-*)
			fatal_usage "Unknown option $1"
			;;
		*)
			# Check if command has already been specified
			if [ ! -z "${COMMAND}" ]; then
				fatal_usage "Unexpected command $1. Multiple commands were specified"
			fi
			COMMAND="${1}"
			shift
			;;
	esac
done

if [ "${COMMAND}" != "clean" ] && [ "${COMMAND}"  != "distclean" ]; then
	require_opt "--prefix" "${PREFIX}"
	require_opt "--targets" "${TARGETS}"
	require_dir_opt "--buildtools" "${BUILDTOOLS}"
fi

require_opt "--objroot" "${OBJROOT}"

if [ -z "${COMMAND}" ]; then
	fatal_usage "Missing required command"
	exit 1
fi

LOGFILE="${OBJROOT}/build.log"

# Run the main routine
main